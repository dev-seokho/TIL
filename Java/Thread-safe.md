# Java thread-safe

## ✅ 동시성 문제가 발생하는 이유

멀티 스레딩은 하나의 프로세스 내에서 여러개의 Thread(PC Register, JVM Stack, Native Method Stack)를 가지며 Method area, Heap영역등은 공유합니다.  
Method area와 Heap영역을 공유하기 때문에 프로그래밍시 동시성 문제가 발생할 수 있습니다.  

## ✅ 동시성 문제 해결법

### ✅ Lock 사용 (Synchronized 키워드 사용)

`synchronized` 키워드를 사용해서 스레드 안정성을 보장할 수 있습니다.   
메서드에 `synchronized` 키워드를 붙여서 동기화를 할 수 있고, `synchronized` 블록을 사용하는 방법도 있습니다.   

### ✅ 자료구조 사용

`java.concurrent` 패키지 하위에 존재하는 자료구조인 `Hashtable`, `ConcurrentHashMap` , `Atomiclnteger` , `BlockingQueue` 등을 사용하여 thread-safe하게 구현할 수 있습니다.   
해당 클래스들은 주요 메서드들이 `synchronized` 키워드에 감싸져있고, 이는 동시성을 보장한다는 사실을 알 수 있습니다.   

### ✅ Stack 한정 프로그래밍

Thread는 프로세스에 할당된 자원(Method area, Heap 영역)은 공유하지만, PC Register, JVM Stack, Native Method Stack은 각 스레드마다 별도로 가지고 있습니다.   
스레드가 각자 고유한 스택과 지역변수를 가진다는 특성을 이해하고 사용하면 동시성을 보장하도록 할 수 있습니다.   

### ✅ ThreadLocal 사용

Stack 한정 프로그래밍을 할 때, 지역변수를 사용하는 것은 메서드 스코프를 벗어나는 순간에 변수 참조가 사라집니다. 그렇기 때문에 해당 변수를 다른 곳에서 이용할 수 없는데, `ThreadLocal` 클래스를 사용하면 쓰레드 영역에 변수를 설정할 수 있습니다.   
`ThreadLocal` 클래스를 사용하면 쓰레드 영역에 변수를 설정하게 되고, 해당 쓰레드가 실행하는 모든 코드에서 해당 쓰레드에 설정된 변수 값을 모두 사용할 수 있게 되는 것 입니다.   

### ✅ 불변객체 사용

불변객체란 객체가 선언된 이후로 변경할 수 없는 객체(ex: String)입니다.   
불변객체는 `setter` 메서드가 없고, 생성자가 `private` 로 설정되어 있으며, 멤버변수들을 `final` 로 선언하기 때문에 동시성을 보장하도록 만들 수 있습니다. 만약 가변객체가 있다면, 방어적 복사본을 생성하는 방식으로 동시성을 보장받을 수 있습니다.   

## ✅ 조사를 하며,

동시성 문제가 생기는 이유는 하나의 프로세스에서 여러개의 쓰레드가 하나의 자원을 공유하기 때문에 일어난다고 생각합니다. 결국 Thread-safe를 구현하기 위해서는 **공유하는 자원을 어떻게 처리해 줄것이냐?** 가 관심주제로 이루어졌던 것 같습니다.   

그렇기 때문에 

- 쓰레드들이 순차적으로 공유 자원을 처리하는 방법(Synchronized)으로 충돌이 일어나지 않게하거나,
- 아예 Read-only(불변객체)로 만들어서 공유 자원을 손대지 못하게 하거나,
- 공유하지 않는 자원(Stack)으로만 프로그래밍을 하며 도움을 주는 클래스를 이용하는 것(ThreadLocal Class)

같은 방식으로 활용한다는 생각이 들었습니다. 결국 동시성 문제를 해결하는것도 JVM의 구조와 성질을 잘 알아야 한다고 느꼈습니다.