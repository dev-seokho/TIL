# java 8 에 추가된 interface 의 기능

### Java 8 이후

Java 8 이후에는 디폴트메소드, 클래스메소드(정적메소드)가 추가 되었습니다.

### 디폴트메소드

default 키워드를 이용하여 작성하는 메소드입니다.
`public default void test(){ //somthing }`

추상 메소드와는 다르게 완전한 메소드 입니다.  
내용을 작성할 수 있으며, override 또한 할 수 있습니다.

기존에 구현한 인터페이스에 메소드를 추가해야하는 경우 디폴트 메소드를 이용하면, 해당 인터페이스를 사용하고 있는 모든 클래스들에게 영향을 주지 않고 메소드를 추가할 수 있습니다.

또한 인터페이스를 상속한 구현체들에게 공통으로 들어갈 코드를 디폴트 메서드에 작성하면 반복을 줄일 수 있습니다.

### 클래스메소드(정적메소드)

클래스 메소드는 인스턴스 생성 없이도 사용이 가능하며, 디폴트메소드와는 다르게 override 할 수 없습니다.

# interface vs abstract 차이

### interface란?

동일한 목적을 가지고 동일한 기능을 강제하기 위해서 사용합니다.
자바의 다형성을 이용하며, 개발코드 수정을 줄이고 유지보수성을 높입니다. 
interface의 모든 멤버 변수는 public static final 이어야 하고, 생략가능합니다. 
또한 모든 메소드는 public abstract 이어야 하고, 이 역시도 생략가능합니다.
interface는 인스턴스를 만들 수 없습니다.

interface를 굳이 한마디로 정의해보자면 기본 설계도라고 표현할 수 있습니다.

### abstract class란?

abstract는 추상 메소드를 사용하여 하위 클래스들이 상속받아 사용할 수 있도록 합니다.
비슷한 특징을 가지고 있는 클래스들에게 사용한다는 특성을 가지고 있으며, 상속의 관계와 비슷합니다.
추상클래스는 생성자가 있고, state(상태)를 가지고 있을 수 있습니다.
abstract class 역시 interface와 마찬가지로 인스턴스를 만들 수 없습니다.

abstract class를 굳이 한마디로 정의해보자면 미완성 설계도로 표현할 수 있습니다.

### interface와 abstract class의 차이점

가장 큰 차이는 상속받은 후에 **상태를 변경할 수 있는가?** 에 대한 차이입니다.
interface의 모든 멤버 변수는 public static final 이기 때문에, 상속 받은 이후 상태변경이 불가능합니다.
반면에 abstract class의 멤버변수는 상속받은 객체의 상태를 변경할 수 있습니다. 

또 다른 차이점들을 알아보겠습니다.

존재 목적의 차이

- interface - 메소드의 구현을 강제, 약속하기 위해서 존재합니다. 구현을 강제함으로써 구현 객체의 같은 동작을 보장할 수 있습니다.
- abstract - 추상 클래스를 클래스가 상속 받아서 필요한 기능들을 이용하고, 확장시키는데 목적이 있습니다.

구현 방법의 차이

- interface - 선언부를 `public inteface` 로 정의합니다.
- abstract - 선언부를 `public abstract class` 로 정의합니다.

선언 방법, 다중상속의 차이

- interface - 클래스 이름 뒤에 `implements(구현하다)` 예약어를 활용해서 선언합니다.
interface는 다중상속이 가능합니다.
- abstract - 클래스 이름 뒤에 `extents(확장하다)` 예약어를 활용해서 선언합니다.
그렇기 때문에 abstract는 다중상속이 불가능합니다.

내부 메소드의 성질의 차이

- interface - interface 내부에 생성된 메소드들은 몸통(body)이 있으면 안됩니다.
한마디로 메소드들이 모조리 추상메소드여야 합니다. 
하지만 java8 부터는 디폴트 메소드와 클래스 메소드가 생기면서 body를 만들 수 있는 방법이 생겼습니다.
- abstract - interface와 다르게 내부에 구현되어 있는 메소드가 있어도 상관 없습니다.
내부에 abstract로 선언된 메소드가 0개 이상 있으면 그 클래스는 반드시 abstract로 선언되어야 합니다.
abstract class는 추상메소드 + 일반메소드로 이루어진 class라고 볼 수 있습니다.

static, final 메소드 사용 가능 여부의 차이

- interface - static, final 메소드를 사용할 수 없습니다.
- abstract - static, final 메소드를 사용해도 상관 없습니다.

상속하는 집합간의 연관관계

- interface - 상속하는 집합간에는 연관관계가 존재하지 않을 수 있습니다.
- abstract - 상속하는 집합간에 연관관계가 있습니다.

생성자 유무

- interface - 생성자를 가질 수 없습니다.
- abstract - 생성자를 가질 수 있습니다.

# interface vs abstract 선택의 기준

다음과 같은 기준을 고려하면 interface, abstract의 선택의 기준을 정할 수 있을 것 같습니다.

### interface를 사용해야할 때

- 다중 상속을 해야할 때
- 계층구조가 필요 없거나 관련없는 클래스를 상속받아야 할 때
- 기능을 구현해야 하지만 누가 동작을 구현하는지는 상관 없을 때

### abstract class를 사용해야할 때

- 명확하게 계층구조가 필요하여 상속관계로 만들어야할 때 (완벽한 is-a 관계이거나 kind of 관계)
- 특정한 요구사항이 필요하지만, 구현 세부 정보의 일부만 필요할 때
- 접근제어자가 public 이 아닌 공통 필드나 메서드를 가지는 클래스를 상속받고자 할 때
- 객체의 상태를 변경하기 위해서 non-final 또는 non-static 필드가 필요할 때


프로그래밍에서 상태는 변화하기 때문에 버그를 많이 주입합니다.

그렇기 때문에 상태 변경의 가능여부로 interface, abstract를 사용 기준점을 잡을 수 있습니다.

완벽한 is-a 관계가 아니라면 abstract 보다는 interface, default method 를 활용합니다.