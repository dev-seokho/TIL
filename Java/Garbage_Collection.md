# GC란?

Java에서 객체가 만들어지면 JVM Heap영역에서 메모리를 점유합니다.
사용되지 않는 객체들은 불필요하게 메모리를 점유하고 있는데, 이를 자동으로 관리해주는 기능이 Garbage Collection 입니다.

`Garbage Collection`은 **메모리를 비워주는 동작**입니다.
`Garbage Collector`는 Garbage Collection을 **동작하는 알고리즘**이며, Java를 실행하기전에 옵션을 지정해줄 수 있습니다.

# GC unreachable, reachability

GC는 Heap 영역에 존재하는 unreachable(아무것도 참조하지 않고 있는)한 객체를 수거합니다.
객체들은 서로 다른 객체를 참조하며 참조 사슬을 이룰 수 있는데, 유효한 참조 여부를 파악하기 위해 언제나 유효한 **최초의 참조**가 있어야 합니다.
이를 객체 참조의 **root set** 이라고 하며, root set으로 부터 시작한 참조 사슬에 속한 객체가 reachable 객체, 무관한 객체가 unreachable 객체입니다.
GC는 이렇게 unreachable 객체를 대상으로 합니다.
이렇게 객체가 Garbage 인지 아닌지 판별하는 개념을 **reachability** 라고 합니다.

# young 영역에 survivor이 2개로 구성되어 있는 이유

Young 영역은 1개의 Eden 과 2개의 Survivor로 나누어져 있습니다.
Eden은 1개이지만 Survivor가 2개인 이유는 **Minor GC가 Eden 뿐만이 아니라 Survivor 영역 또한 대상으로 하기 때문**입니다.

Eden 영역이 가득 차게 되면 Minor GC가 발생하는데요, 이때 Eden과 비어있지않은 한개의 Survivor(Survivor 0) 에서 모두 Minor GC가 일어나며 살아남은 객체는 비어있는 나머지 Survivor (Survivor 1)로 이동하게 됩니다. 

이후 Survivor0과 Survivor1 은 **청소의 대상**과 **복사받는 입장**이되는 역할을 서로 바꾸게 됩니다.
복사받는 입장의 역할을 맡는 Survivor는 항상 비어 있는 상태로 살아남은 객체를 받을 수 있는 준비를 해야합니다.

만약 Survivor 영역이 2개가 아니라 1개라면, **살아남은 객체가 옮겨갈 수 있는 대상이 없기 때문에 2개가 존재**해야 합니다.

참고사항으로는 Survivor에서 다른 Survivor로 옮기는 행동을 노화(aging)라고 부릅니다.

# 트래픽이 무지 많이 몰리는 이벤트가 예정되어있을때, young 영역과 old 영역비율은?

대용량 트래픽 상황에서 **무조건적으로 Young 영역의 비중을 높인다거나, Old 버전의 비중을 높이는 것이 아닌 애플리케이션의 특징을 파악하고, 성능 테스트나 모니터링 후에 young 영역과 old 영역 비중을 정해야 한다고 생각합니다.**

그 이유는 애플리케이션마다 객체의 크기도 다르고 살아 있는 기간도 다르기 때문입니다.

GC가 일어날 때는 **Stop the World**가 발생합니다.
Stop the World가 실행되면 GC를 실행하는 쓰레드를 제외한 나머지 쓰레드는 작업이 중단되고, GC가 완료되면 작업이 재개됩니다.

Stop the World가 가장 임팩트 있게 나타나는 시간을 파악하고 이를 줄여준다면 성능 개선을 기대할 수 있다고 생각합니다.
이를 기반으로 Young 영역의 비중과 Old 영역의 비중을 고려해보겠습니다.

**Minor GC의 빈도수로 인해 Stop the world 가 많이 일어나는 애플리케이션**

→ Young 영역을 적절하게 늘려주기

Young 영역은 Weak Generational 가설(객체 대부분이 아주 짧은 시간 동안만 살아남는다는 가설)에 따라서 단명하는 젊은 객체들이 존재하는 공간입니다.

그렇기 때문에, 대부부분의 객체가 Young 영역에서 사라지고, 새로 생성되는 객체가 할당되기 때문에 **GC가 굉장히 자주 일어나는 영역** 입니다.

Young 영역의  Eden이 가득 차게되면 일어나는 GC 를 Minor GC라고 부르는데, Minor GC는 수명이 짧은 객체를 검사하고, 많은 객체들을 검사하지 않기 때문에 속도가 빠른 GC입니다.

애플리케이션에서 새로운 객체 할당이 많아서 Minor GC의 빈도수로 인한 Stop the world가 많이 일어난다면, Young 영역의 비중을 적절하게 높여주어 Minor GC의 빈도수를 줄여주는 것이 좋다고 생각합니다.

**Minor GC의 실행 시간으로 인해 Stop the world 가 많이 일어나는 애플리케이션**

→ Young 영역을 적절하게 줄여주기

기본적으로 Minor GC는 자주 일어나기때문에 실행 시간이 짧아야 합니다.
만약 애플리케이션에 수명이 긴 객체가 많거나 새로운 객체 할당이 많이 없는 객체의 경우에는 Young 영역의 사이즈를 적절하게 줄여준다면 Minor GC 빈도수 자체는 이전보다 많아질지라도 수거해가는 객체의 수는 적어지기 때문에 실행 시간의 개선을 기대할 수 있습니다.

**Major GC의 빈도수로 인해 Stop the world 가 많이 일어나는 애플리케이션**

→ Old 영역을 적절하게 늘려주기

Old 영역은 Young 영역의 Minor GC로 부터 살아남은 객체들이 존재하는 공간입니다.
(Old 영역으로 올 수 있는 Minor GC의 횟수는 설정 가능합니다.)

Old 영역의 메모리가 가득 차게 되면 일어나는 GC를 Major GC라고 부릅니다.

Old 영역에 Young영역으로부터 살아남은 객체가 많이 들어와서 Major GC가 발생하는 횟수가 많이 일어나고, 이것이 Stop the world에 미치는 영향이 크다면, Old 영역을 적절하게 늘려주어 Major GC의 빈도수를 조절해주는 방안이 필요합니다. 

**Major GC의 실행 시간으로 인해 Stop the world 가 많이 일어나는 애플리케이션**

→ Old 영역을 적절하기 줄여주기

 Major GC는 Minor GC에 비해 시간이 오래 걸립니다.

만약 Old 영역의 메모리가 커서 많은 양의 객체에 대한 GC가 이루어진다면 Stop the world의 시간도 길어질 것입니다. 이때는 Old 영역을 적절하기 줄여주어서 Stop the world 시간이 줄어드는 것을 기대해볼 수 있겠습니다.

**대용량 트래픽이 발생하면 꼭 성능 개선을 GC로만 해야할까요?**

Java 기반의 서비스에서 GC의 Young, Old 영역에 대한 비중 튜닝이 이루어지기 전에 다른 성능 개선 방안들도 있습니다. 
예를 들어서 애플리케이션 내의 객체 생성을 줄이는 방안이라던가, 여러 개의 인스턴스를 동시에 생성하고 로드 밸런싱을 통해서 부하를 분산시켜주는 방법도 있습니다.

그렇기 때문에 대용량 트래픽이 발생한다면, 여러가지 상황을 판단해서 trade-off를 고려하고 우선순위를 결정하는게 가장 좋은 방법이라고 생각합니다.

# GC의 종류

# JAVA8 default GC
