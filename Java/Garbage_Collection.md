# GC란?

### GC가 생겨난 이유

GC의 기능이 없는 언어들에서는 사람이 직접 메모리를 할당하고, 메모리를 해제하는 작업을 진행해야헸고, 사람들이 메모리 해제를 까먹는 휴먼에러가 발생하게 됩니다.

결국에는 메모리가 점점 쌓이며 프로그램이 꺼지는 등의 문제가 발생했었는데, 이를 수도관에서 물이 새는 누수 현상에 비유하여 **Memory Leak(메모리 누수)** 라고 합니다.

개발자들은 이런 현상을 보완하기 위해서 GC를 개발합니다.

### GC란?

Java에서 객체가 만들어지면 JVM Heap영역에서 메모리를 점유합니다.
사용되지 않는 객체들은 불필요하게 메모리를 점유하고 있는데, 이를 자동으로 관리해주는 기능이 Garbage Collection 입니다.

`Garbage Collection`은 **메모리를 비워주는 동작**입니다.
`Garbage Collector`는 Garbage Collection을 **동작하는 알고리즘**이며, Java를 실행하기전에 옵션을 지정해줄 수 있습니다.

# GC unreachable, reachability

GC는 Heap 영역에 존재하는 unreachable(아무것도 참조하지 않고 있는)한 객체를 수거합니다.
객체들은 서로 다른 객체를 참조하며 참조 사슬을 이룰 수 있는데, 유효한 참조 여부를 파악하기 위해 언제나 유효한 **최초의 참조**가 있어야 합니다.
이를 객체 참조의 **root set** 이라고 하며, root set으로 부터 시작한 참조 사슬에 속한 객체가 reachable 객체, 무관한 객체가 unreachable 객체입니다.
GC는 이렇게 unreachable 객체를 대상으로 합니다.
이렇게 객체가 Garbage 인지 아닌지 판별하는 개념을 **reachability** 라고 합니다.

# young 영역에 Survivor이 2개로 구성되어 있는 이유

Young 영역은 1개의 Eden 과 2개의 Survivor로 나누어져 있습니다.
Eden은 1개이지만 Survivor가 2개인 이유는 **Minor GC가 Eden 뿐만이 아니라 Survivor 영역 또한 대상으로 하기 때문**입니다.

Eden 영역이 가득 차게 되면 Minor GC가 발생하는데요, 이때 Eden과 비어있지않은 한개의 Survivor(Survivor 0) 에서 모두 Minor GC가 일어나며 살아남은 객체는 비어있는 나머지 Survivor (Survivor 1)로 이동하게 됩니다. 

이후 Survivor0과 Survivor1 은 **청소의 대상**과 **복사받는 입장**이되는 역할을 서로 바꾸게 됩니다.
복사받는 입장의 역할을 맡는 Survivor는 항상 비어 있는 상태로 살아남은 객체를 받을 수 있는 준비를 해야합니다.

만약 Survivor 영역이 2개가 아니라 1개라면, **살아남은 객체가 옮겨갈 수 있는 대상이 없기 때문에 2개가 존재**해야 합니다.

참고사항으로는 Survivor에서 다른 Survivor로 옮기는 행동을 노화(aging)라고 부릅니다.

# GC에서 Survivor이 2개인 또다른 이유 중 하나인 "메모리 파편화"란?

# 트래픽이 무지 많이 몰리는 이벤트가 예정되어있을때, young 영역과 old 영역비율은?

대용량 트래픽 상황에서 **무조건적으로 Young 영역의 비중을 높인다거나, Old 버전의 비중을 높이는 것이 아닌 애플리케이션의 특징을 파악하고, 성능 테스트나 모니터링 후에 young 영역과 old 영역 비중을 정해야 한다고 생각합니다.**

그 이유는 애플리케이션마다 객체의 크기도 다르고 살아 있는 기간도 다르기 때문입니다.

GC가 일어날 때는 **Stop the World**가 발생합니다.
Stop the World가 실행되면 GC를 실행하는 쓰레드를 제외한 나머지 쓰레드는 작업이 중단되고, GC가 완료되면 작업이 재개됩니다.

Stop the World가 가장 임팩트 있게 나타나는 시간을 파악하고 이를 줄여준다면 성능 개선을 기대할 수 있다고 생각합니다.
이를 기반으로 Young 영역의 비중과 Old 영역의 비중을 고려해보겠습니다.

### Minor GC의 빈도수로 인해 Stop the world 가 많이 일어나는 애플리케이션
`→ Young 영역을 적절하게 늘려주기`

Young 영역은 Weak Generational 가설(객체 대부분이 아주 짧은 시간 동안만 살아남는다는 가설)에 따라서 단명하는 젊은 객체들이 존재하는 공간입니다.

그렇기 때문에, 대부부분의 객체가 Young 영역에서 사라지고, 새로 생성되는 객체가 할당되기 때문에 **GC가 굉장히 자주 일어나는 영역** 입니다.

Young 영역의  Eden이 가득 차게되면 일어나는 GC 를 Minor GC라고 부르는데, Minor GC는 수명이 짧은 객체를 검사하고, 많은 객체들을 검사하지 않기 때문에 속도가 빠른 GC입니다.

애플리케이션에서 새로운 객체 할당이 많아서 Minor GC의 빈도수로 인한 Stop the world가 많이 일어난다면, Young 영역의 비중을 적절하게 높여주어 Minor GC의 빈도수를 줄여주는 것이 좋다고 생각합니다.

### Minor GC의 실행 시간으로 인해 Stop the world 가 많이 일어나는 애플리케이션
`→ Young 영역을 적절하게 줄여주기`

기본적으로 Minor GC는 자주 일어나기때문에 실행 시간이 짧아야 합니다.
만약 애플리케이션에 수명이 긴 객체가 많거나 새로운 객체 할당이 많이 없는 객체의 경우에는 Young 영역의 사이즈를 적절하게 줄여준다면 Minor GC 빈도수 자체는 이전보다 많아질지라도 수거해가는 객체의 수는 적어지기 때문에 실행 시간의 개선을 기대할 수 있습니다.

### Major GC의 빈도수로 인해 Stop the world 가 많이 일어나는 애플리케이션
`→ Old 영역을 적절하게 늘려주기`

Old 영역은 Young 영역의 Minor GC로 부터 살아남은 객체들이 존재하는 공간입니다.
(Old 영역으로 올 수 있는 Minor GC의 횟수는 설정 가능합니다.)

Old 영역의 메모리가 가득 차게 되면 일어나는 GC를 Major GC라고 부릅니다.

Old 영역에 Young영역으로부터 살아남은 객체가 많이 들어와서 Major GC가 발생하는 횟수가 많이 일어나고, 이것이 Stop the world에 미치는 영향이 크다면, Old 영역을 적절하게 늘려주어 Major GC의 빈도수를 조절해주는 방안이 필요합니다. 

### Major GC의 실행 시간으로 인해 Stop the world 가 많이 일어나는 애플리케이션
`→ Old 영역을 적절하기 줄여주기`

 Major GC는 Minor GC에 비해 시간이 오래 걸립니다.

만약 Old 영역의 메모리가 커서 많은 양의 객체에 대한 GC가 이루어진다면 Stop the world의 시간도 길어질 것입니다. 이때는 Old 영역을 적절하기 줄여주어서 Stop the world 시간이 줄어드는 것을 기대해볼 수 있겠습니다.

### 기본적인 크기할당은 어떻게 돼 있을까요?

기본적으로 young 영역과 old 영역의 default 비율은 `young 1 : 3 old` 입니다. 
old 영역이 young 영역보다 3배 크게 설정 되어있습니다.

### 대용량 트래픽이 발생하면 꼭 성능 개선을 GC로만 해야할까요?

Java 기반의 서비스에서 GC의 Young, Old 영역에 대한 비중 튜닝이 이루어지기 전에 다른 성능 개선 방안들도 있습니다. 
예를 들어서 애플리케이션 내의 객체 생성을 줄이는 방안이라던가, 여러 개의 인스턴스를 동시에 생성하고 로드 밸런싱을 통해서 부하를 분산시켜주는 방법도 있습니다.

그렇기 때문에 대용량 트래픽이 발생한다면, 여러가지 상황을 판단해서 trade-off를 고려하고 우선순위를 결정하는게 가장 좋은 방법이라고 생각합니다.

# GC의 종류

### ✅ Serial GC
적은 메모리와 CPU 코어 개수가 적을 때 적합한 방식입니다.
**운영 서버에서 절대 사용하면 안되는 방식**인데, 데스크톱 CPU 코어가 하나만 있을 때 사용하기 위해서 만든 방식이기 때문에 Serial GC를 사용하면 애플리케이션의 성능이 많이 떨어집니다.

사용하는 알고리즘은 mark(객체식별)-sweap(살아있는 객체 남기기)-compaction(앞부분 부터 객체를 연속적으로 다시 쌓기) 방법 입니다.

**32비트 JVM** 에서 돌아가는 싱글쓰레드 어플리케이션에서 사용합니다.
**Minor GC와 Major GC**가 일어날 때 올스탑(Stop the world) 합니다.
**싱글쓰레드** 방식입니다.

### ✅ Parallel GC(Throughput Garbage Collector)

Serial GC와는 다르게 메모리가 충분하고 코어의 개수가 많을 때 유리한 GC 입니다.

Serial GC 와 기본적인 알고리즘은 같습니다. 하지만 처리하는 쓰레드가 멀티쓰레드이기 때문에 Serial GC보다 빠르게 객체를 처리할 수 있습니다.

**64비트 JVM** 이나 **멀티 CPU** 유닉스 머신에서 기본 GC로 설정되어 있습니다.
**Minor GC와 Major GC**가 일어날 때 올스탑(Stop the world) 합니다.
멀티**쓰레드** 방식입니다.

### ✅ Parallel Old GC

JDK 5 update 6부터 제공한 GC방식인데, Parallel GC와 비교했을 때, Old 영역의 알고리즘이 다릅니다.

사용하는 알고리즘은 mark(객체식별)-summary(GC 수행 영역에서 별도로 살아있는 객체를 식별)-compaction(앞부분 부터 객체를 연속적으로 다시 쌓기) 방법 입니다.

### ✅ CMS GC(Concurrent Mark-Sweep GC, Low Latency GC)

Stop the world 시간이 매우 짧은 GC입니다. 모든 애플리케이션의 응답 속도가 매우 중요할 때 CMS GC를 사용합니다.

**Initial Mark** 단계에서 참조 상태인 객체를 짧은 시간에 Marking 후, 올스탑 없이 **Concurrent Mark** 단계에서 참조상태 객체를 확인합니다.

**Remark** 단계에서 변경되거나 추가된 객체를 확인하고, **Concurrent Sweep** 단계에서 참조 되지 않는 객체를 정리합니다.

메모리와 CPU 리소스를 많이 사용하는 것이 단점입니다.
Compaction 단계가 기본적으로 제공되지 않아서 메모리 파편화가 일어나는 것도 단점입니다. 직접 Compaction을 수행해주어야합니다.

### ✅ G1 GC(Garbage First)

CMS GC의 단점을 보완하고 대체하기 위해 만들어진 GC 입니다.

Young, Old 영역을 물리적으로 나누지 않고 Heap 영역에 Resion 이라는 논리적 단위로 나누어서 리하는 개념을 도입했습니다.
하나 이상의 Resion 에서 객체를 복사해 다른 Resion 으로 이동 시키는 방식입니다.

CMS와 비슷한 방식으로 동작을 시작하고, **Heap 영역에 전역적으로 Making** 한 뒤, 가장 많은 공간이 있는 곳 부터 메모리 회수를 진행합니다.

이 때문에 Garbage First 라는 이름이 붙었습니다.

CMS Collector의 CPU 리소스 및 메모리 파편화의 단점을 해결하였습니다.

단점은 적은 Heap 공간을 가지는 Application 에서는 제 성능을 발휘하지 못하고 Full GC가 발생한다는 점.