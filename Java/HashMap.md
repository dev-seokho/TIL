# HashMap과 해시 충돌

## HashMap은 어떻게 구현되어 있을까?

### ✅ HashMap이란?

Map이라는 것은 키(Key)와 값(Value) 두 쌍으로 데이터를 보관하는 자료구조입니다.
Map의 특징은 키와 값으로 이루어져 있고, **키는 맵에 유일하게 있어야 하며, 값은 중복되어도 상관 없다**는 것입니다.

Java에는 Map을 상속받는 Hashtable, HashMap, SortedMap등이 있는데, HashMap은 그 중 하나입니다.

### ✅ HashMap은 어떻게 구현 돼 있길래 키와 값을 빠르게 매핑할까?

HashMap에 객체가 들어가면 해시 함수의 결과 값에 따라서 bucket이 만들어 집니다.
bucket속에 해당 객체가 들어가며, 이 후 HashMap은 값을 찾을 때 key, hashCode(), equals()를 기반으로 값을 바로 찾을 수 있습니다.
만약 모든 bucket에 객체가 1개라면 HashMap의 시간 복잡도는 O(1)이 됩니다.

### ✅ HashMap의 시간 복잡도는 언제나 O(1)일까? (해시충돌)

동일하지 않은 객체 X, Y가 있을때 X.hashCode() ≠ Y.hasCode() 라면 이 때 사용하는 해시 함수를 완전한 해시 함수(perfect hash functions)라고 합니다.

String이나 POJO(plain old java object)같은 경우에는 완전한 해시 함수를 구현이 논리적으로 불가능하며, 그렇다고  bucket 수를 최대로 할당하는 것도 좋지 않습니다.
그 이유는 다음과 같은데,

1. HashMap은 각 객체의 hashCode()를 사용하여 해시 함수를 만드는데, 이는 int형을 return 합니다. 
int 는 2^32 로 논리적으로 생성가능한 객체 수보다 적으며, 완전한 해시 함수를 구현할 수 없습니다.
2. 객체가 얼마나 생성될지 모르는 상황에서 최댓값(2^32)까지 빈공간을 할당하기에는 할당된 메모리의 많은 부분들이 사용되지 않은 상태일 수도 있고, 공간이 낭비되며, 검색효율이 나빠질 수도 있습니다.

결국 서로 다른 객체가 한개의 bucket을 함께 사용하는 것은 피할 수 없으며, 이런 상황을 **해시충돌이라고 합니다.** 
bucket의 내부는 List로 이루어져 있기 때문에 해시충돌이 일어난 bucket에서는 시간복잡도가 O(1)이 아닌 O(N)이 될 수 있습니다.

### ✅ 해시충돌 해결법

개발자들은 HashMap의 해시충돌을 해결하기 위해 Seprate Chaining과 보조해시함수를 사용하도록 했습니다.
Java 8 이전에는 Seprate Chaining에서 링크드 리스트를 사용해 시간복잡도를 낮췄다면, Java 8 이후에는 트리를 사용하며 HashMap의 성능을 계속해서 향상시키고 있습니다.