# Stream

객체지향 언어인 Java에 함수형 프로그래밍을 가능하게 만들기 위한 노력이 Java 8 부터 시도되었는데, Stream API 또한 그 중 하나입니다.  Stream API는 데이터를 추상화하고, 처리하는데 자주 사용되는 함수들을 정의해 두었으며, “연속된 정보"를 처리하는데 사용됩니다.

## Stream의 연산 종류

Stream은 생성하기(스트림 생성), 가공하기(중개 연산, 중간 연산), 결과 만들기(종단 연산, 종료 연산) 3가지로 구분할 수 있습니다.  

이들의 특징은 다음과 같습니다.

1. 생성하기(스트림 생성)
    1. Stream 객체를 생성합니다.
    2. 재사용이 불가능하기 때문에, Stream이 닫히면 재생성해주어야 합니다.
2. 가공하기 (중개 연산, 중간 연산)
    1. 원본의 데이터를 별도의 데이터로 가공하기 위한 중간 연산입니다. 어떤 객체의 Stream을 원하는 형태로 처리할 수 있습니다.
    2. 연산 결과를 Stream으로 다시 반환하기 때문에 연속해서 중간 연산을 이어나갈 수 있습니다.
3. 결과 만들기 (종료 연산)
    1. 가공된 데이터로부터 원하는 결과를 만들기 위한 최종 연산입니다.
    2. Stream의 요소들을 소모하면서 연산이 수행되기 때문에 1번만 처리 가능합니다.

## Stream 예시 코드

```java
List<String> tmp = Arrays.asList("test1", "test2", "test3", "test4");
tmp.stream().filter(x -> x.with("test")).count();

```

이 예시 코드에서 `stream()` 은 Stream 객체를 생성하는 스트림 생성,    
`filter(x → x.startsWith(”test”))` 는 Stream 객체를 가공하는 중간 연산,    
`count()` 는 Stream 객체에서 원하는 결과를 만드는 최종 연산 단계인 종료 연산 입니다.   

## Stream의 중간 연산이 수행되는 시점

중간 연산은 종료 연산이 실행되기전까지 중간 연산이 실행되지 않습니다.  
보통 이러한 성질을 두고 `게으른 연산(lazy한 처리)` 라고 얘기를 합니다.

중간 연산은 종료 연산이 실행되기 전까지 새로운 Stream 인스턴스를 돌려주기만 할 뿐 어떠한 작업도 하지 않습니다. 이러한 방식으로 인해서 loop fusion(루프 퓨전)과 short circuit(쇼트 서킷) 이라는 기술을 사용할 수 있습니다.

- **루프 퓨전**

루프 퓨전이란 모든 요소가 각 단계를 한번에 거치는 것이 아니라 개별적인 요소가 한개씩 for문이 돌 듯 순차적으로 거치는 방식입니다.

```java
List<String> tmp = Arrays.asList("test1", "test2", "test3", "test4");
tmp.stream().filter(...).skip(...).count();
```

이와 같은 코드에서 모든 객체가 filter를 통과하고 skip을 통과하는 것이 아니라 요소마다 순차적 연산이 됩니다.

1. "test1" 이 filter 통과 -> skip 통과
2. "test2" 가 filter 통과 -> skip 통과
3. "test3" 이 filter 통과 -> skip 통과
4. "test4" 가 filter 통과 -> skip 통과
5. count()

- **쇼트 서킷**

쇼트 서킷이란 일련의 논리연산을 진행 할 때 결과가 확실하다면 나머지 연산을 진행하지 않는 것을 의미 합니다.

```java
public static boolean testShortCircuit() {
	if (testOne() || testTwo()) return true;
	return false;
}
```

이와 같은 코드에서 testOne()이 만약 `true` 라면 or 연산이기 때문에 무조건 `true` 를 return 합니다.  
고로 testTwo()는 연산할 필요가 없어지며 이를 쇼트 서킷이라고 합니다.  
Stream의 중간 연산에서도 만약 **limit(5)와 같이 limit가 걸려 있다면, 이후의 요소에 대해서는 연산을 진행할 필요가 없어집니다.**

## Stream 을 무조건 사용해야할까? (Stream의 장단점)

Stream을 사용하면 코드를 더욱 간결하고 가독성 있게 정리할 수 있으며, **원본의 데이터에 변형을 가하지 않습니다. 또한 일회용이며, 내부 반복으로 작업을 처리합니다.** 이로 인해서 가독성이 좋고, 코드의 변경이 쉽고 유연하다는 장점을 가지고 있습니다.  

하지만 Stream을 무조건 사용해야하는 것은 아닙니다. Stream은 생성하는데 적지않은 리소스를 소모하며, 사용 방법에 따라 속도를 줄일 수는 있지만, 극단적으로 설명하면 **for-loop가 Stream 보다 빠르다고 얘기할 수 있습니다.** 그래서 주식 매매와 같이 성능이 아주 주요한 이슈라면 Stream 에 대한 사용을 다시 고려해볼 필요가 있습니다.  

또한 코드의 반복문이 외부에 노출되어 있는 것이 아니라 내부에 숨겨져 있다는  것 자체로 단점이 될 수 있는데, 만약 루프 퓨전과 같은 Stream의 특징을 잘 모른다면 내부적으로 오류가 생겼을 때 어떤 부분에서 문제가 생겼는지 알 수 없으며, 디버깅이 힘들어진다는 문제가 생깁니다.  

여담으로 알고리즘 문제를 풀 때 Stream을 사용해서 풀면 타임오버가 생기는 경우도 있다고 합니다 🙂  