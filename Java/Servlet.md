# 서블릿

- 서블릿 : 웹애플리케이션을 만들 때 필요한 인터페이스

초창기 어플리케이션에서는 정적데이터만 제공할 수 있었다.

이를 해결하기 위해 CGI(Common gate interface)라는 것이 등장했다. 이는 동적데이터를 전송하기 위한 규약을 말한다.

 CGI는 몇가지 문제가 있었는데, 모든 사용자 요청마다 프로세스를 사용해서 요청을 처리했고, 이는 곧 서버의 많은 리소스를 차지하는 문제를 야기했다. 또다른 문제로 같은 요청이 와도 동일한 CGI 구현체를 만들게 되는 구조를 가지고 있었다. 이러한 문제를 해결하기 위해서 서블릿이 등장하게 됐다.

서블릿은 자바진영에서 동적데이터를 제공하기 위해서 CGI를 기반으로 제작된 프로그램이다.

서블릿은 Process를 Thread로, 동일 구현체 생성을 싱글톤 패턴으로 적용하여 CGI의 문제를 해결했다.

**서블릿을 사용함으로 개발자의 이점은 HTTP 통신에서 메시지 파싱을 API를 통해서 도와준다는 점이다.**

서블릿은 누가 생성하는 것인가?

서블릿 컨테이너(톰캣)라는 녀석인데, 서블릿은 생성시 init(), 제거시 destory()를 사용하면서 생성과 삭제가 되는데, 서블릿 컨테이너는 이것을 담당하면서 서블릿의 생명 주기를 담당한다.

1. 클라이언트 요청이 오면 서블릿 컨테이너는 해당 요청과 매핑된 서블릿을 가지는 작업을 한다.
2. 서블릿이 생성되어 있지 않다면 생성 이후에 1번작업을 실행한다.
3. 그 후 서블릿은 서블릿 컨테이너 안에 존재하게 된다.
4. 또다시 같은 매핑되어 있는 요청이 온다면 서블릿 컨테이너 안에 있는 서블릿을 재사용한다.
5. 종료되는 시점은 보통 컨테이너가 종료되는 시점이며, 특정 서블릿이 로드, 언로드 될때이다.

서블릿의 문제점

서블릿은 각 요청마다 새로이 서블릿 객체가 생성되기 때문에 10개의 요청이 있다면 10개의 서블릿이 생성된다.

그렇게 될 경우 핵심 비즈니스 로직이 매번 반복돼서 수행되는 경우가 있었다.

그래서 공통로직을 앞단에서 걸러주는 방식을 생각하게 된다. 이를 바로 Front Controller pattern라고 한다.

프론트컨트롤러 패턴을 통해서 하나의 서블릿을 통해서 요청을 처리할 수 있었고, 이를 통해 관리가 쉬워진다.

이 프론트 컨트롤러가 하는 일은 다음과 같다.

1. 클라이언트와 서버를 연결
2. 각 요청에 맞는 컨트롤러를 매핑하여 정보를 보관
3. 요청이 들어오면 매핑 정보를 찾아 해당 컨트롤러 호출
4. 전달할 결과를 생성
5. 결과를 사용자에게 반환

그래서 프론트 컨트롤러의 역할을 다음과 같이 분리했다.

이렇게 프론트 컨트롤러의 역할을 나눔으로써 객체지향적인 모습을 가지게 됐고 다음과 같은 문제점들을 해결했다.

1. Servlet의 service() 메서드에 공동퇴는 비즈니스 로직 해결
2. 컨트롤러에서 공통으로 처리해야 하는 로직이 생기면 중복이 발생하는 것 해결
3. Servlet에 종속적인 구조를 가지는 것 해결
4. FrontController의 책임이 많았던 것을 해결

그리고 이런 일련의 구조 개선을 통해서 구현된 것이 Spring MVC 라고 볼 수 있다.
Spring MVC는 이와같은 구조를 띄는데, Front Controller가 Dispatcher Servlet으로 변경 된 것과 핸들러 어댑터가 추가 돼어 좀 더 확장성 있게 개발할 수 있도록 했다.

**개발자는 이를 통해서 비즈니스 로직에 집중할 수 있다!(핸들러(컨트롤러))**

Dispatcher SErvlet은 모든 요청을 먼저 받게 되고 세부 컨트롤러로 위임한다. (공통적으로 진행되야 할 작업들을 우선적으로 처리해준다)