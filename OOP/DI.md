# DI와 의존성 주입에서 생성자 주입을 사용해야 하는 이유

## DI란? (feat. Ioc)

DI는 객체지향 프로그래밍에서 통용되는 개념으로, Dependency Injection (의존관계 주입)을 나타냅니다.객체 내부에서 다른 객체를 생성하는 것은 **강한 결합도**를 가지는 구조입니다. 

이러한 강한 결합도는 변화에 유연하지 않습니다. A라는 클래스 내부에서 B라는 객체가 직접 생성되고 있다면, B객체를 C객체로 수정하고 싶을 때, A 클래스가 수정돼야 합니다. 이는 변화에는 닫혀있고, 확장에는 열려 있어야 하는 OCP(개방 폐쇄 원칙)을 위반하게 됩니다. B가 C객체로 수정되면서 A 클래스가 변화해야만 하기 때문입니다.

또한 A클래스 내부에서 B라는 객체를 생성하게 된다면, 객체를 의존하게 되는 것입니다. 이는 역할이나 추상에 의존하는 것이 아닌 **실체 자체를 의존**함으로써 DIP 원칙을 위반하게 됩니다.

객체지향 프로그래밍에서는 이를 해결하기 위해서 A클래스 내부에서 B나 C객체를 생성하는 것이 아니라 외부에서 생성된 객체를 인터페이스를 사용해서 넘겨줍니다. 이를 **DI(의존관계 주입)**이라고 합니다.

또한 DI를 사용할 때, 스프링에서는 개발자가 흐름에 따라서 `new` 를 사용하여 객체를 제어를 하는 것이 아닌 런타임 환경에서 스프링 컨테이너가 의존관계를 결정하게 합니다. 결국 제어권을 가진 주체가 개발자에서 스프링으로 변경되며 이를 **Ioc(제어의 역전)** 이라고 합니다.

## DI를 하는 여러가지 방법

의존관계 주입에는 다음과 같은 방법들이 존재합니다.

- 생성자 주입
- 수정자 주입(setter)
- 필드 주입
- 일반 메서드 주입

### **🙆🏻‍♂️ 수정자 주입(setter)**

```java
public class Car {
	
	private Tire tire;

	public void setTire(Tire tire) {
		this.tire = tire;
	}
}

public class Driver {
	public static void main(String[] args) {
		Tire tire = new KoreaTire();
		Car car = new Car();
		car.setTire(tire);
	}
```

위에서 볼 수 있 듯 setter를 사용하면, **언제든지 변경될 위험이 존재**합니다.  
setter를 사용해서 의존성을 주입해야 하기 때문에 setXxxx 메서드의 **접근 제어자를 public으로 열어두기 때문입니다.**

대부분의 의존관계 주입은 한번 일어나면 애플리케이션 종료시점까지 의존관계를 변경할 일이 거의 존재하지 않기 때문에, 이렇게 언제든지 변경될 위험이 존재한다는 것은 단점입니다.

### **🙆🏻‍♂️ 필드 주입**

```java
public class Car {
	
	@Autowired
	private Tire tire;
}
```

필드 주입은 @Autowired를 사용하여 코드가 굉장히 간결하지만, 외부에서 변경하기가 힘듭니다.  
프레임워크에 의존적이고 객체지향적으로 좋지 않으며, 순수 자바 코드로 테스트를 작성하기 쉽지 않습니다

### **🙆🏻‍♂️ 생성자 주입**

```java
public class Car {
	private final Tire tire;

	public OrderService(Tire tire) {
		this.tire = tire;
	}
}

public class Driver {
	public static void main(String[] args) {
		Tire tire = new KoreaTire();
		Car car = new Car(tire);
```

- 불변

생성자 호출 시점에 딱 1번만 호출되는 것이 보장되기 때문에, **불변**하게 설계할 수 있습니다. 실제로 개발을 하다 보면 의존 관계의 변경이 필요한 상황은 거의 없습니다. 

- final 키워드

불변하게 설계하기 떄문에 final 키워드를 사용하는데, **final 키워드는 곧 Lombok과의 결합에서 이점**을 줍니다.

- 컴파일 오류의 활용(필수적 생성자 호출)

생성자 주입을 사용하면 **의존성 주입을 누락하는 것을 방지**할 수 있기 때문에 컴파일 오류로 누락을 방지 합니다. 

- 테스트

생성자 주입은 특정 프레임워크에 의존적인 필드 주입과는 다르게 순수 자바 코드로 테스트를 할 수 있습니다. 이는 프레임워크를 떠나서 순수 객체지향적으로도 좋다는 모습을 볼 수  있습니다.

- Spring의 @Autowired 편의성

스프링에서는 생성자가 단 하나만 있다면 @Autowired 어노테이션을 생략해도 자동 주입됩니다.

## 결론적으로 생성자 주입을 사용해야한다.

의존성 주입을 할 수 있는 방법들은 여러가지가 있지만, 생성자 주입의 이점들과, 생성자 주입이 아닌 다른 의존성 주입 방식의 단점들로 인해서 최근에는 기본적으로 생성자 주입이 권장되고 있습니다.

물론 어떠한 기술을 사용할 때 무조건이라는 것은 없으며 트레이드오프를 고려해야하지만, 생성자 주입이 주는 이점은 객체지향적으로도 유의미한 장점들이라고 생각합니다.