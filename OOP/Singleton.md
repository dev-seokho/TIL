# 싱글톤 

### 싱글톤 패턴

싱글톤 패턴의 정의는 **객체의 인스턴스가 1개만 생성되는 패턴**을 의미합니다.
예를 들어서 커넥션 풀, 스레드 풀, 디바이스 설정 객체 등과 같은 경우 인스턴스를 여러 개 만들면 불필요한 자원을 사용하게 되고 프로그램이 예상치 못한 결과를 낳을 수 있습니다.

또한 Spring 같은 경우는 기본적으로 웹애플리케이션을 대상으로 하는 프레임워크이기 때문에, 스프링 컨테이너의 객체들을 싱글톤으로 관리합니다. 만약 그렇지 않으면 사용하는 클라이언트들이 많아지면 많아질수록 여러개의 인스턴스가 생성되어 불필요한 메모리소모를 일으키며 많은 GC를 일으키기 때문입니다.

결국 싱글톤은 인스턴스가 1개만 생성되어 공유하도록 만드는 디자인패턴입니다.

### 싱글톤패턴의 장점

1. 위에서 설명했듯 한개의 인스턴스를 사용해서 공유하는 방식이기 때문에 여러개의 인스턴스를 생성하는 것보다 메모리 관점에서 장점이 있습니다. 이는 곧 속도 측면에서도 장점이 있다는 사실을 보여줍니다.
2. 싱글톤 인스턴스는 전역으로 사용되는 인스턴스이기 때문에 다른 클래스의 인스턴스들이 접근하여 사용할 수 있습니다. 즉 클래스 간에 데이터 공유가 쉽습니다.

### 싱글톤패턴의 단점

1. 싱글톤 인스턴스는 전역으로 사용되는 인스턴스이기 때문에 클래스 간에 데이터 공유가 쉽다는 장점이 있지만, 이는 곧 인스턴스의 데이터에 여러 스레드가 동시에 접근하게 된다면 동시성 문제가 생길 수도 있다는 단점을 가지고 있습니다. 즉 싱글톤 패턴은 동시성에서 자유롭지 않습니다.
그렇기 때문에 싱글톤 패턴을 설계할 때는 최대한 상태를 가지지 못하게 해야하며, 읽기전용으로 만들어야 할 수도 있습니다.
2. 싱글톤 인스턴스는 단 하나의 자원을 공유하고 있기 때문에 테스트가 온전하게 수행되지 못할 수도 있습니다. 이를 해결하기 위해서는 매번 인스턴스의 상태를 초기화 시켜주어야할수도 있는데, 이는 곧 테스트가 어렵다는 것을 뜻합니다.
3. 클라이언트가 구체 클래스에 의존하게 됩니다. new 키워드를 사용해서 직접 클래스 안에서 객체를 생성하며, 이는 DIP를 위반하고, OCP 원칙을 위반하게 될 수도 있습니다. 
이를 위반한다는 것은 곧 객체지향의 장점인 유연성을 활용하지 못할 수도 있다는 점을 보여줍니다.

### 싱글톤 패턴을 만드는 방법

**🙆🏻‍♂️ 기본적인 방법 (Eager initialization (이른 초기화 방식))**

싱글톤 패턴을 만들기 위해서는 다음과 같은 요소들이 필요합니다.

- new를 실행할 수 없도록 생성자에 private 접근 제어자를 지정
- 유일한 단일 객체를 반환할 수 있는 정적(static) 메서드가  필요
- 유일한 단일 객체를 참조할 정적(static) 참조 변수가 필요

```java
public class Singleton {
	static Singleton final instance = new Singleton();

	private Singleton() { };

		public static Singleton getInstance() {
			return instance;
	}
```

- 장점

기본적인 방법의 장점은 static으로 생성된 변수에 싱글톤 객체를 선언했기 때문에 클래스 로더에 의해 클래스가 로딩 될 때 싱글톤 객체가 생성됩니다. 또 클래스 로더에 의해 클래스가 최초 로딩 될 때 객체가 생성됨으로 Thread-safe합니다.

- 단점

단점으로는 싱글톤객체 사용유무와 관계없이 클래스가 로딩되는 시점에 항상 싱글톤 객체가 생성되기 때문에 메모리 관점에서는 비효율적일수도 있습니다.

**🙆🏻‍♂️ Double checked locking pattern (DCLP)**

**🙆🏻‍♂️ Lazy holder**

```java
public class Singleton {
	private Singleton() { };
	
	private static class SingletonHolder {
		private static final Singleton instance = new Singleton();
	}

	public static Singleton getInstance() {
		return SingletonHolder.instance;
		
```
**🙆🏻‍♂️ Enum singleton**
컴파일 시점에 생성되기 떄문에 Reflection 공격에 안전하다.

직렬화가 자동으로 가능하다.

lazy initialization이 불가능하다.